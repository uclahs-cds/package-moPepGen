""" A brute forth algorithm for calling variant peptides from a GVF file. """
import sys
import argparse
import copy
from typing import Iterable, List, Dict, Tuple
from pathlib import Path
from itertools import combinations
from Bio import SeqUtils
from moPepGen import seqvar, aa, dna
from moPepGen.SeqFeature import FeatureLocation
from moPepGen.cli.common import add_args_cleavage, print_help_if_missing_args
from moPepGen.seqvar.VariantRecord import VariantRecord
from moPepGen.util.common import load_references


# pylint: disable=W0212
def add_subparser_brute_force(subparsers:argparse._SubParsersAction):
    """ parse command line arguments """
    parser:argparse.ArgumentParser = subparsers.add_parser(
        name='bruteForce',
        help='Call variant peptide with the brute force algorithm.'
    )
    parser.add_argument(
        '-i', '--input-gvf',
        type=Path,
        help='GVF file',
        nargs="+"
    )
    parser.add_argument(
        '-r', '--reference-dir',
        type=Path,
        help='Reference directory. Must contain genome.fa, annotation.gtf, and'
        ' proteome.fasta. The directory should be generated by'
        ' the downsampleReference command'
    )
    parser.add_argument(
        '-f', '--force',
        action='store_true',
        help='If not set, the program stops when there are more than 10'
        ' variants. When this flag is set, the program runs anyway. Noted that '
        ' the runtime is going to increase quickly after 10 variants.',
        default=False
    )
    parser.add_argument(
        '--variant-ids',
        type=str,
        help='List of variant labels.',
        nargs='*'
    )
    add_args_cleavage(parser)
    parser.set_defaults(func=brute_force)
    print_help_if_missing_args(parser)
    return parser

def _parse_exclusion(exclusion) -> Tuple:
    """ Parse exclusion to values """
    start, ref, alt = exclusion.split('-')
    return int(start), ref, alt

def parse_variant_exclusion(exclusions:List[str]) -> Dict[Tuple,List[Tuple]]:
    """ Parse exclusion variants into """
    groups = {}
    for exclusion in exclusions:
        variant, targets = exclusion.split(':')
        targets = targets.split(',')
        variant = _parse_exclusion(variant)
        targets = [_parse_exclusion(target) for target in targets]
        groups[variant] = targets
    return groups

def brute_force(args):
    """ main """

    anno, genome, proteome = load_references(
        path_anno=args.reference_dir/'annotation.gtf',
        path_genome=args.reference_dir/'genome.fasta',
        path_proteome=args.reference_dir/'proteome.fasta'
    )

    rule = args.cleavage_rule
    exception = 'trypsin_exception' if rule == 'trypsin' else None
    canonical_peptides = proteome.create_unique_peptide_pool(
        anno=anno, rule=rule, exception=exception,
        miscleavage=args.miscleavage, min_mw=args.min_mw,
        min_length=args.min_length, max_length=args.max_length
    )

    variant_pool = seqvar.VariantRecordPool()
    for gvf_file in args.input_gvf:
        with open(gvf_file) as handle:
            variant_pool.load_variants(handle, anno, genome)

    if not variant_pool.data:
        return

    tx_id = list(variant_pool.data.keys())[0]

    tx_model = anno.transcripts[tx_id]
    tx_seq = tx_model.get_transcript_sequence(genome['chr1'])

    variant_peptides = set()

    if tx_seq.orf:
        start_index = tx_seq.orf.start + 3
    else:
        start_index = 3
    variants:List[VariantRecord] = []

    series = variant_pool[tx_id]

    for variant in series.transcriptional:
        if variant.location.start < start_index -1:
            continue
        if tx_model.is_mrna_end_nf() and variant.location.end <= tx_seq.orf.end - 3:
            continue
        if args.variant_ids:
            if variant.id not in args.variant_ids:
                continue
        if variant.location.start == start_index - 1:
            variant.to_end_inclusion(tx_seq)
        variants.append(variant)

    if len(variants) > 10 and not args.force:
        raise ValueError(
            f"{len(variants)} variants is too many for this brute force algorithm."
        )

    for i in range(len(variants)):
        for comb in combinations(variants, i + 1):
            skip = False

            for j, left in enumerate(comb):
                if j == len(comb) - 1:
                    continue
                for right in comb[j+1:]:
                    if left.location.end >= right.location.start:
                        skip = True

            if tx_model.is_mrna_end_nf():
                for variant in comb:
                    if variant.location.end >= tx_seq.orf.end:
                        skip = True
                        break

            if skip:
                continue

            seq = tx_seq.seq
            offset = 0
            if tx_model.is_protein_coding and tx_model.is_mrna_end_nf():
                cur_cds_end = tx_seq.orf.end

            for variant in comb:
                start = variant.location.start + offset
                end = variant.location.end + offset
                if tx_model.is_protein_coding and tx_model.is_mrna_end_nf():
                    cur_cds_end += len(variant.alt) - len(variant.ref)
                offset = offset + len(variant.alt) - len(variant.ref)
                seq = seq[:start] + variant.alt + seq[end:]

            if not (tx_model.is_protein_coding and tx_model.is_mrna_end_nf()):
                cur_cds_end = len(seq)

            if not tx_model.is_protein_coding:
                alt_seq = dna.DNASeqRecord(seq)
                cds_start_positions = alt_seq.find_all_start_codons()
            else:
                cds_start = tx_seq.orf.start
                cds_start_positions = [cds_start]

            for cds_start in cds_start_positions:
                if not tx_model.is_protein_coding:
                    cur_cds_end = len(seq)
                else:
                    cur_cds_end = cur_cds_end - (cur_cds_end - cds_start) % 3

                aa_seq = seq[cds_start:cur_cds_end].translate(to_stop=True)
                aa_seq = aa.AminoAcidSeqRecord(seq=aa_seq)

                sites = aa_seq.find_all_enzymatic_cleave_sites('trypsin', 'trypsin_exception')
                sites.insert(0, 0)
                sites.append(len(aa_seq))
                for j, lhs in enumerate(sites[:-1]):
                    for k in range(j + 1, min([j + 3, len(sites) - 1]) + 1):
                        rhs = sites[k]
                        tx_lhs = cds_start + lhs * 3
                        tx_rhs = cds_start + rhs * 3
                        if not has_any_variant(tx_lhs, tx_rhs, cds_start, comb, tx_seq.seq):
                            continue

                        peptides = [aa_seq[lhs:rhs]]
                        if peptides[0].seq.startswith('M') and lhs == 0:
                            peptides.append(peptides[0][1:])
                        for peptide in peptides:
                            is_valid = peptide_is_valid(peptide.seq, canonical_peptides,
                                args.min_length, args.max_length, args.min_mw)
                            if is_valid:
                                variant_peptides.add(str(peptide.seq))

    variant_peptides = list(variant_peptides)
    variant_peptides.sort()
    for peptide in variant_peptides:
        print(peptide, file=sys.stdout)

def peptide_is_valid(peptide:str, canonical_peptides:str, min_length:int,
        max_length:int, min_mw:float) -> bool:
    """ Check whether the peptide is valid """
    if canonical_peptides and peptide in canonical_peptides:
        return False
    return min_length <= len(peptide) <= max_length and \
        SeqUtils.molecular_weight(peptide, 'protein') >= min_mw


def has_any_variant(lhs:int, rhs:int, cds_start:int,
        variants:Iterable[VariantRecord], tx_seq:str) -> bool:
    """ Check whether the given range of the transcript has any variant
    associated. """
    offset = 0
    query = FeatureLocation(start=lhs, end=rhs)
    for variant in variants:
        var_size = len(variant.alt) - len(variant.ref)
        loc = FeatureLocation(
            start=variant.location.start + offset,
            end=variant.location.end + offset + var_size
        )
        if loc.start > rhs + 3:
            break
        is_frameshifting = cds_start < loc.start and variant.is_frameshifting()
        is_cleavage_gain = (cds_start != lhs \
                    and (loc.overlaps(FeatureLocation(start=lhs-3, end=lhs)))) \
                or loc.overlaps(FeatureLocation(start=rhs, end=rhs+3))
        orf_index = cds_start % 3
        codon_pos = loc.start - (loc.start - orf_index) % 3
        is_stop_lost = cds_start < loc.start \
                and tx_seq[codon_pos:codon_pos + 3] in ['TAA', 'TAG', 'TGA']
        if loc.overlaps(query) \
                or cds_start in loc \
                or is_frameshifting \
                or is_cleavage_gain \
                or is_stop_lost:
            return True
        offset += var_size
    return False
