""" `callVariant` is the core of moPepGen. It takes multiple GVF files, generated
by any moPepGen parser, and calls variant peptides caused by genomic variants
using a graph-based algorithm. For any transcript, it creates a three-frame
transcript variant graph by incorporating all variants from any sources (SNV,
INDEL, fusion, alternative splicing, RNA editing, and circRNA). The transcript
variant graph is then translated into a peptide variant graph, followed by
converting to a cleavage graph based on the enzymatic cleavage rule. The
variant peptide graph is than used to call for variant peptides that contains
at least one variant, and do not present in the canonical peptide pool.
 """
from __future__ import annotations
import argparse
import inspect
from typing import List, Set, TYPE_CHECKING
from pathlib import Path
from pathos.multiprocessing import ProcessPool
from multiprocessing.managers import BaseManager, NamespaceProxy
from moPepGen import svgraph, aa, seqvar, logger, circ
from moPepGen.cli.common import add_args_cleavage, add_args_quiet, \
    print_start_message, print_help_if_missing_args, add_args_reference, \
    load_references
from moPepGen.dna.DNASeqDict import DNASeqDict
from moPepGen.gtf.GenomicAnnotation import GenomicAnnotation
from moPepGen.seqvar.VariantRecordPoolOnDisk import TranscriptionalVariantSeries, VariantRecordPoolOnDisk, VariantRecordPoolOnDiskOpener


if TYPE_CHECKING:
    from moPepGen import dna, gtf
    from moPepGen.circ.CircRNA import CircRNAModel


# pylint: disable=W0212
def add_subparser_call_variant(subparsers:argparse._SubParsersAction):
    """ CLI for moPepGen callPeptides """
    p:argparse.ArgumentParser = subparsers.add_parser(
        name='callVariant',
        help='Call non-canonical peptides from genomic variants.',
        description="Genomic variant data must be generated by one of the"
        "moPepGen parser. See moPepGen --help",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )

    p.add_argument(
        '-i', '--input-variant',
        type=Path,
        nargs='+',
        help='Path to input variant files. Must be generated by any of the'
        'moPepGen parser. This can be multiple.',
        metavar='<file>',
        required=True
    )
    p.add_argument(
        '-o', '--output-fasta',
        type=Path,
        help='Filename for the output FASTA.',
        metavar='<file>',
        required=True
    )
    p.add_argument(
        '--max-variants-per-node',
        type=int,
        help='Maximal number of variants per node. This argument can be useful'
        ' when there are local regions that are heavily mutated. When creating'
        ' the cleavage graph, nodes containing variants larger than this value'
        ' are skipped. Setting to -1 will avoid checking for this.',
        default=-1,
        metavar='<number>'
    )
    p.add_argument(
        '--noncanonical-transcripts',
        action='store_true',
        help='Process only noncanonical transcripts of fusion transcripts and'
        'circRNA. Canonical transcripts are skipped.'
    )
    p.add_argument(
        '--verbose-level',
        type=int,
        help='Level of verbose for logging.',
        default=1,
        metavar='<number>'
    )
    p.add_argument(
        '--threads',
        type=int,
        help='Set number of threads to be used.',
        default=1,
        metavar='<number>'
    )
    add_args_reference(p)
    add_args_cleavage(p)
    add_args_quiet(p)

    p.set_defaults(func=call_variant_peptide)
    print_help_if_missing_args(p)
    return p

class ProxyBase(NamespaceProxy):
    _exposed_ = ('__getattribute__', '__setattr__', '__delattr__')

class ReferenceBundleProxy(ProxyBase): pass

class VariantRecordPoolOnDiskProxy(ProxyBase): pass

def register_proxy(name, cls, proxy, additional_attrs=None):
    if additional_attrs is None:
        additional_attrs = []
    for attr in dir(cls):
        if (inspect.ismethod(getattr(cls, attr)) and not attr.startswith("__")) \
                or attr in additional_attrs:
            proxy._exposed_ += (attr,)
            setattr(proxy, attr,
                    lambda s: object.__getattribute__(s, '_callmethod')(attr))
    BaseManager.register(name, cls, proxy)
class ReferenceBundle():
    """ """
    def __init__(self, genome:DNASeqDict, anno:GenomicAnnotation):
        self.genome = genome
        self.anno = anno

class VariantRecordPoolOnDiskWrapper():
    def __init__(self, pool:VariantRecordPoolOnDisk):
        """ """
        self.pool = pool

class VariantPeptideCaller():
    """ Helper class to call variant peptides """
    def __init__(self, args:argparse.Namespace):
        """ constructor """
        self.args = args
        self.variant_files:List[str] = args.input_variant
        self.output_fasta:str = args.output_fasta
        self.quiet:bool = args.quiet
        self.rule:str = args.cleavage_rule
        self.miscleavage:int = int(args.miscleavage)
        self.min_mw:float = float(args.min_mw)
        self.exception = 'trypsin_exception' if self.rule == 'trypsin' else None
        self.min_length:int = args.min_length
        self.max_length:int = args.max_length
        self.max_variants_per_node:int = args.max_variants_per_node
        self.noncanonical_transcripts = args.noncanonical_transcripts
        self.verbose = args.verbose_level
        self.threads = args.threads
        if self.quiet is True:
            self.verbose = 0
        self.reference_bundle:ReferenceBundle = None
        self.genome:DNASeqDict = None
        self.anno:GenomicAnnotation = None
        self.canonical_peptides:Set[str] = None
        self.variant_pools:List[seqvar.VariantRecordPoolOnDisk] = None
        self.variant_pool_wrappers:List[VariantRecordPoolOnDiskWrapper] = None
        self.variant_peptides = aa.VariantPeptidePool()
        self.tx_ids:List[str] = []

    def load_reference(self, manager:BaseManager):
        """ load reference genome, annotation, and canonical peptides """
        self.genome, self.anno, _, self.canonical_peptides = load_references(self.args)
        self.reference_bundle = manager.ReferenceBundle(self.genome, self.anno)

    def create_in_disk_vairant_pool(self):
        """ Create in disk variant pool """
        pool = VariantRecordPoolOnDisk(
            gvf_files=self.variant_files, anno=self.anno, genome=self.genome
        )
        with VariantRecordPoolOnDiskOpener(pool):
            tx_ids = pool.pointers.keys()
        tx_rank = self.anno.get_transcirpt_rank()
        self.tx_ids = sorted(tx_ids, key=lambda x:tx_rank[x])

        self.variant_pools = []
        for _ in range(self.threads):
            pool = VariantRecordPoolOnDisk(
                pointers=None, gvf_files=self.variant_files,
                anno=self.anno, genome=self.genome
            )
            self.variant_pools.append(pool)

    def call_variant_peptides_wrapper(self, i:int, tx_id:str
            ) -> List[Set[aa.AminoAcidSeqRecord]]:
        """ """
        pool = self.variant_pool_wrappers[i].pool
        series = pool[tx_id]
        peptide_pool = []
        if series.transcriptional:
            peptides = self.call_variants_main(tx_id, series.transcriptional, pool)
            peptide_pool.append(peptides)

        for fusion_variant in series.fusion:
            peptides = self.call_variants_fusion(fusion_variant, pool)
            peptide_pool.append(peptides)

        for circ_model in series.circ_rna:
            peptides = self.call_variants_circ_rna(circ_model, pool)
            peptide_pool.append(peptides)

        return peptide_pool

    def call_variants_main(self, tx_id:str, tx_variants:List[seqvar.VariantRecord],
            pool:seqvar.VariantRecordPoolOnDisk):
        """ main variant peptide caller """
        try:
            return call_peptide_main(
                tx_id=tx_id, tx_variants=tx_variants, variant_pool=pool,
                anno=self.reference_bundle.anno, genome=self.reference_bundle.genome,
                rule=self.rule, exception=self.exception, miscleavage=self.miscleavage,
                max_variants_per_node=self.max_variants_per_node
            )
        except:
            logger(f'Exception raised from {tx_id}')
            raise

    def call_variants_fusion(self, variant:seqvar.VariantRecord,
            pool:seqvar.VariantRecordPoolOnDisk):
        """ call variant peptides from fusion transcripts """
        if self.verbose >= 2:
            logger(variant.id)
        try:
            return call_peptide_fusion(
                variant=variant, variant_pool=pool,
                anno=self.reference_bundle.anno, genome=self.reference_bundle.genome,
                rule=self.rule, exception=self.exception, miscleavage=self.miscleavage,
                max_variants_per_node=self.max_variants_per_node
            )
        except:
            logger(f"Exception raised from fusion {variant.id}")
            raise

    def call_variants_circ_rna(self, circ_model:CircRNAModel,
            pool:seqvar.VariantRecordPoolOnDisk):
        """ call variant peptides from circRNA """
        try:
            return call_peptide_circ_rna(
                record=circ_model, variant_pool=pool,
                anno=self.reference_bundle.anno, genome=self.reference_bundle.genome,
                rule=self.rule, exception=self.exception, miscleavage=self.miscleavage,
                max_variants_per_node=self.max_variants_per_node
            )
        except:
            logger(f"Exception raised from {circ_model.id}")
            raise

    def write_fasta(self):
        """ write variant peptides to fasta. """
        self.variant_peptides.write(self.output_fasta)
        if self.verbose >= 1:
            logger('Variant peptide FASTA file written to disk.')

class VariantPeptideCallerOpener():
    """ """
    def __init__(self, caller:VariantPeptideCaller,
            pool_openers:List[VariantRecordPoolOnDiskOpener]=None):
        """ constructor """
        self.caller = caller
        self.pool_openers = pool_openers or []

    def __enter__(self):
        """ enter """
        for pool in self.caller.variant_pools:
            opener = VariantRecordPoolOnDiskOpener(pool)
            opener.open()
            self.pool_openers.append(opener)
        return self.caller

    def __exit__(self, exception_type, exception_value, exception_traceback):
        """ """
        for opener in self.pool_openers:
            opener.close()

def call_variant_peptides(caller):
    """ call variant peptides """
    process_pool = ProcessPool(caller.threads)
    tx_bench = []
    for i,key in enumerate(caller.tx_ids):
        if caller.verbose >= 2:
            logger(key)
        tx_bench.append(key)
        if len(tx_bench) >= caller.threads or i == len(caller.tx_ids) - 1:
            results = process_pool.map(
                caller.call_variant_peptides_wrapper,
                list(range(len(tx_bench))), tx_bench
            )
            for peptide_series in results:
                for peptides in peptide_series:
                    for peptide in peptides:
                        caller.variant_peptides.add_peptide(
                            peptide=peptide,
                            canonical_peptides=caller.canonical_peptides,
                            min_mw=caller.min_mw, min_length=caller.min_length,
                            max_length=caller.max_length
                        )
            tx_bench = []

        if caller.verbose >= 1:
            if i % 1000 == 0:
                logger(f'{i} transcripts processed.')

def call_variant_peptide(args:argparse.Namespace) -> None:
    """ Main entry point for calling variant peptide """
    register_proxy('ReferenceBundle', ReferenceBundle, ReferenceBundleProxy)
    register_proxy(
        'VariantRecordPoolOnDiskWrapper', VariantRecordPoolOnDiskWrapper,
        VariantRecordPoolOnDiskProxy
    )
    manager = BaseManager()
    manager.start()
    caller = VariantPeptideCaller(args)
    print_start_message(args)
    caller.load_reference(manager)
    caller.create_in_disk_vairant_pool()
    with VariantPeptideCallerOpener(caller):
        caller.variant_pool_wrappers = []
        for pool in caller.variant_pools:
            pool_wrapper = manager.VariantRecordPoolOnDiskWrapper(pool)
            caller.variant_pool_wrappers.append(pool_wrapper)
        call_variant_peptides(caller)
        caller.write_fasta()

def call_peptide_main(tx_id:str, tx_variants:List[seqvar.VariantRecord],
        variant_pool:seqvar.VariantRecordPoolOnDisk, anno:gtf.GenomicAnnotation,
        genome:dna.DNASeqDict, rule:str, exception:str, miscleavage:int,
        max_variants_per_node:int) -> Set[aa.AminoAcidSeqRecord]:
    """ Call variant peptides for main variants (except cirRNA). """
    tx_model = anno.transcripts[tx_id]
    chrom = tx_model.transcript.location.seqname
    transcript_seq = tx_model.get_transcript_sequence(genome[chrom])

    dgraph = svgraph.ThreeFrameTVG(
        seq=transcript_seq,
        _id=tx_id,
        cds_start_nf=tx_model.is_cds_start_nf(),
        has_known_orf=tx_model.is_protein_coding,
        mrna_end_nf=tx_model.is_mrna_end_nf(),
        max_variants_per_node=max_variants_per_node
    )
    dgraph.init_three_frames()
    dgraph.create_variant_graph(tx_variants, variant_pool, genome, anno)
    dgraph.fit_into_codons()
    pgraph = dgraph.translate()

    pgraph.create_cleavage_graph(rule=rule, exception=exception)
    return pgraph.call_variant_peptides(miscleavage=miscleavage)

def call_peptide_fusion(variant:seqvar.VariantRecord,
    variant_pool:seqvar.VariantRecordPoolOnDisk, anno:gtf.GenomicAnnotation,
    genome:dna.DNASeqDict, rule:str, exception:str, miscleavage:int,
    max_variants_per_node:int) -> Set[aa.AminoAcidSeqRecord]:
    """ Call variant peptides for fusion """
    tx_id = variant.location.seqname
    tx_model = anno.transcripts[tx_id]
    chrom = tx_model.transcript.chrom
    tx_seq = tx_model.get_transcript_sequence(genome[chrom])
    tx_seq = tx_seq[:variant.location.end]

    if tx_id in variant_pool:
        tx_variants = [x for x in variant_pool[tx_id].transcriptional
            if x.location.end < variant.location.end]
    else:
        tx_variants = []

    tx_variants.append(variant)

    dgraph = svgraph.ThreeFrameTVG(
        seq=tx_seq,
        _id=tx_id,
        cds_start_nf=tx_model.is_cds_start_nf(),
        has_known_orf=tx_model.is_protein_coding,
        mrna_end_nf=tx_model.is_mrna_end_nf(),
        max_variants_per_node=max_variants_per_node
    )
    dgraph.init_three_frames()
    dgraph.create_variant_graph(tx_variants, variant_pool, genome, anno)
    dgraph.fit_into_codons()
    pgraph = dgraph.translate()
    pgraph.create_cleavage_graph(rule=rule, exception=exception)
    return pgraph.call_variant_peptides(miscleavage=miscleavage)

def call_peptide_circ_rna(record:circ.CircRNAModel,
        variant_pool:seqvar.VariantRecordPool,
        annotation:gtf.GenomicAnnotation, genome:dna.DNASeqDict,
        rule:str,
        exception:str, miscleavage:int, max_variants_per_node:int
        )-> Set[aa.AminoAcidSeqRecord]:
    """ Call variant peptides from a given circRNA """
    gene_id = record.gene_id
    gene_model = annotation.genes[gene_id]
    chrom = gene_model.location.seqname
    gene_seq = gene_model.get_gene_sequence(genome[chrom])
    circ_seq = record.get_circ_rna_sequence(gene_seq)

    # Alternative splicing should not be included. Alternative splicing
    # represented as Insertion, Deletion or Substitution.
    exclusion_variant_types = ['Insertion', 'Deletion', 'Substitution']

    variant_records = variant_pool.filter_variants(
        gene_id=gene_id, exclude_type=exclusion_variant_types,
        intron=False, segments=record.fragments
    )

    cgraph = svgraph.ThreeFrameCVG(
        circ_seq, _id=record.id, circ_record=record,
        max_variants_per_node=max_variants_per_node
    )
    cgraph.init_three_frames()
    cgraph.create_variant_circ_graph(variant_records)
    cgraph.extend_loop()
    cgraph.truncate_three_frames()
    cgraph.fit_into_codons()
    pgraph = cgraph.translate()
    pgraph.create_cleavage_graph(rule=rule, exception=exception)
    return pgraph.call_variant_peptides(miscleavage=miscleavage)
