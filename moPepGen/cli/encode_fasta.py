""" This module takes in a variant peptide FASTA file and encodes the fasta
headers with 36-digit long UUID (32 digits of hexdecimal characters and 4
hypens). The original headers together with  the UUIDs arer saved into the
dict file at the same location. This resolves the problems that some proteomic
search engines have strick requirement on the FASTA header length. """
from __future__ import annotations
import argparse
from pathlib import Path
from typing import TYPE_CHECKING
import uuid
from Bio import SeqIO
from Bio.SeqIO import FastaIO
from moPepGen.cli import common


if TYPE_CHECKING:
    from Bio.SeqRecord import SeqRecord

INPUT_FILE_FORMATS = ['.fa', '.fasta']
OUTPUT_FILE_FORMATS = ['.fa', '.fasta']

def add_subparser_encode_fasta(subparser:argparse._SubParsersAction):
    """ CLI for moPepGen encodeFasta """
    parser:argparse.ArgumentParser = subparser.add_parser(
        name='encodeFasta',
        help='Encode variant peptide FASTA file header.',
        description='Encode variant peptide FASTA file header.',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    common.add_args_input_path(
        parser=parser, formats=INPUT_FILE_FORMATS,
        message='Input FASTA file, must be generated by moPepGen callVariant.'
    )
    common.add_args_output_path(
        parser=parser, formats=OUTPUT_FILE_FORMATS
    )
    common.print_help_if_missing_args(parser)
    parser.set_defaults(func=encode_fasta)
    return parser

def encode_fasta(args:argparse.Namespace) -> None:
    """ encode fasta """
    input_path:Path = args.input_path
    output_path:Path = args.output_path
    common.validate_file_format(input_path, INPUT_FILE_FORMATS, True)
    common.validate_file_format(input_path, OUTPUT_FILE_FORMATS, True)

    fasta_dict = output_path.with_suffix(output_path.suffix + '.dict')

    with open(input_path, 'rt') as in_handle, \
            open(output_path, 'wt') as out_handle, \
            open(fasta_dict, 'wt') as dict_handle:
        record2title = lambda x: x.description
        writer = FastaIO.FastaWriter(out_handle, record2title=record2title)
        record:SeqRecord
        for record in SeqIO.parse(in_handle, 'fasta'):
            header = record.description
            index = str(uuid.uuid4())
            dict_handle.write(f"{index}\t{header}" + '\n')
            record.description = index
            writer.write_record(record)
